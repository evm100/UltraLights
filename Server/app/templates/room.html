{% extends "base.html" %}
{% block content %}
<div class="mb-6 flex justify-between items-center">
  <h2 class="text-2xl font-semibold">Nodes</h2>
  <button id="addNode" class="w-12 h-12 flex items-center justify-center text-2xl rounded-full bg-indigo-600 hover:bg-indigo-500">+</button>
</div>
<div class="grid md:grid-cols-3 gap-4">
  {% for n in room.nodes %}
  <a href="/node/{{ n.id }}" class="glass rounded-xl p-4 block hover:ring-2 hover:ring-indigo-400">
    <div class="text-sm opacity-70 uppercase tracking-wide">{{ n.kind|upper }}</div>
    <div class="text-xl font-semibold">{{ n.name }}</div>
    <div class="opacity-60 text-xs mt-2">ID: {{ n.id }}</div>
  </a>
  {% endfor %}
</div>
<div class="mt-8" id="presetSection">
  <div class="flex flex-wrap items-center justify-between gap-3 mb-4">
    <h2 class="text-2xl font-semibold">Presets</h2>
    <button id="presetSaveButton" type="button" class="glass px-4 py-2 rounded-lg text-sm font-semibold tracking-wide uppercase hover:ring-2 hover:ring-indigo-400">Save Preset</button>
  </div>
  <div id="presetStatus" class="text-sm mb-3 opacity-80" role="status" aria-live="polite"></div>
  <div id="presetList" class="flex flex-wrap gap-2" data-house-id="{{ house.id }}" data-room-id="{{ room.id }}" data-api-base="/api/house/{{ house.id }}/room/{{ room.id }}" data-initial-presets='{{ presets|tojson }}'>
    {% for p in presets %}
    <div class="preset-item" data-preset-id="{{ p.id }}" data-custom="{{ 'true' if p.source == 'custom' else 'false' }}">
      <button class="preset preset-button glass px-4 py-2 rounded-lg hover:ring-2 hover:ring-indigo-400" type="button" data-preset-id="{{ p.id }}">{{ p.name or p.id }}</button>
      {% if p.source == 'custom' %}
      <button class="preset-delete" type="button" aria-label="Delete preset {{ p.name or p.id }}" data-preset-id="{{ p.id }}">✕</button>
      {% endif %}
    </div>
    {% else %}
    <div class="opacity-60">No presets configured.</div>
    {% endfor %}
  </div>
</div>
{% if motion_config %}
<div class="mt-8" id="motionSchedule" data-save-url="/api/house/{{ house.id }}/room/{{ room.id }}/motion-schedule" data-slot-minutes="{{ motion_config.slot_minutes|default(60) }}">
  <h2 class="text-2xl font-semibold mb-4">Motion Schedule</h2>
  <div class="glass rounded-xl p-4 overflow-x-auto">
    <div class="motion-schedule-grid" id="motionScheduleGrid">
      {% for slot in motion_config.schedule %}
      <div class="motion-schedule-slot" data-slot="{{ loop.index0 }}">
        <span class="motion-schedule-hour"></span>
        <span class="motion-schedule-label"></span>
      </div>
      {% endfor %}
    </div>
  </div>
  <div class="glass rounded-xl p-4 mt-4">
    <div class="flex flex-wrap gap-4 items-end">
      <label class="motion-field">
        <span class="motion-field-label">From</span>
        <select id="motionScheduleStart" class="motion-select"></select>
      </label>
      <label class="motion-field">
        <span class="motion-field-label">To</span>
        <select id="motionScheduleEnd" class="motion-select"></select>
      </label>
      <label class="motion-field flex-1 min-w-[180px]">
        <span class="motion-field-label">Preset</span>
        <select id="motionSchedulePreset" class="motion-select w-full">
          <option value="">No Motion</option>
          {% for preset in presets %}
          <option value="{{ preset.id }}">{{ preset.name }}</option>
          {% endfor %}
        </select>
      </label>
      <button id="motionScheduleApply" class="motion-button">Apply to Range</button>
      <button id="motionScheduleSave" class="motion-button motion-button--primary">Save Schedule</button>
    </div>
    <div id="motionScheduleStatus" class="text-sm mt-3 opacity-80"></div>
  </div>
  <div class="glass rounded-xl p-4 mt-4">
    <div class="text-xs uppercase tracking-wide opacity-70 mb-2">Legend</div>
    <div class="flex flex-wrap gap-2">
      <div class="motion-legend-item">
        <span class="motion-legend-swatch" style="--swatch-color: {{ motion_config.no_motion_color }}"></span>
        <span class="motion-legend-label">No Motion</span>
      </div>
      {% for entry in motion_config.legend %}
      <div class="motion-legend-item">
        <span class="motion-legend-swatch" style="--swatch-color: {{ entry.color }}"></span>
        <span class="motion-legend-label">{{ entry.name }}</span>
      </div>
      {% endfor %}
    </div>
  </div>
</div>
<div class="mt-8" id="motionImmunity" data-fetch-url="/api/house/{{ house.id }}/room/{{ room.id }}/motion-immune" data-save-url="/api/house/{{ house.id }}/room/{{ room.id }}/motion-immune">
  <h2 class="text-2xl font-semibold mb-4">Motion Immunity</h2>
  <div class="glass rounded-xl p-4">
    <p class="text-sm opacity-80 mb-3">Select nodes to ignore when motion automations run.</p>
    <div class="motion-immunity-status text-sm opacity-80 mb-3" role="status" aria-live="polite"></div>
    {% if room.nodes %}
    <div class="space-y-3" id="motionImmunityList" role="group" aria-label="Motion immunity nodes">
      {% for n in room.nodes %}
      <label class="flex items-center gap-3 motion-immunity-option">
        <input type="checkbox"
               class="motion-immunity-checkbox"
               value="{{ n.id }}"
               data-node-id="{{ n.id }}"
               aria-label="Ignore {{ n.name }} ({{ n.id }})" />
        <span>
          <span class="font-semibold">{{ n.name }}</span>
          <span class="block text-xs uppercase tracking-wide opacity-60">ID: {{ n.id }}</span>
        </span>
      </label>
      {% endfor %}
    </div>
    <button type="button" class="motion-button motion-button--primary mt-4 motion-immunity-save">Save Changes</button>
    {% else %}
    <div class="opacity-60">No nodes available for motion immunity.</div>
    {% endif %}
  </div>
</div>
<div class="mt-8">
  <h2 class="text-2xl font-semibold mb-4">Motion Timer</h2>
  {% if motion_config.sensors %}
  <div id="motionTimerList" class="space-y-4">
    {% for sensor in motion_config.sensors %}
    <div class="glass rounded-xl p-4 motion-timer" data-node="{{ sensor.node_id }}">
      <div class="flex flex-wrap items-center justify-between gap-2 mb-3">
        <div>
          <div class="text-lg font-semibold">{{ sensor.node_name }}</div>
          <div class="text-xs uppercase tracking-wide opacity-60">
            {{ 'Enabled' if sensor.enabled else 'Disabled' }}
          </div>
        </div>
        <div class="motion-timer-label text-sm font-semibold"></div>
      </div>
      <input type="range"
             id="motionTimer-{{ loop.index0 }}"
             class="motion-timer-slider w-full"
             min="10"
             max="3600"
             step="10"
             value="{{ sensor.duration }}"
             data-node="{{ sensor.node_id }}"
             data-enabled="{{ 'true' if sensor.enabled else 'false' }}" />
    </div>
    {% endfor %}
  </div>
  {% else %}
  <div class="opacity-60">No PIR sensors reported.</div>
  {% endif %}
</div>
{% endif %}
<script type="module" src="/static/presets.js"></script>
<script>
document.getElementById('addNode').onclick = async () => {
  const name = prompt('New node name');
  if(!name) return;
  const res = await fetch('/api/house/{{ house.id }}/room/{{ room.id }}/nodes', {
    method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name})
  });
  if(res.ok) location.reload(); else alert('Failed to add node');
};
{% if motion_config %}
(function(){
  const scheduleContainer = document.getElementById('motionSchedule');
  if (scheduleContainer) {
    const scheduleGrid = document.getElementById('motionScheduleGrid');
    const scheduleData = {{ motion_config.schedule|tojson }};
    if (!Array.isArray(scheduleData)) {
      return;
    }
    if (!scheduleData.length) {
      scheduleData.push(null);
    }
    const palette = [
      "#f97316",
      "#38bdf8",
      "#a855f7",
      "#22c55e",
      "#eab308",
      "#f43f5e",
      "#6366f1",
      "#14b8a6",
      "#ec4899",
      "#facc15",
    ];
    let presetNames = {{ motion_config.preset_names|tojson }};
    let presetColors = {{ motion_config.preset_colors|tojson }};
    const noMotionColor = "{{ motion_config.no_motion_color }}";
    const slotMinutes = parseInt(scheduleContainer.dataset.slotMinutes || "60", 10) || 60;
    const startSelect = document.getElementById('motionScheduleStart');
    const endSelect = document.getElementById('motionScheduleEnd');
    const presetSelect = document.getElementById('motionSchedulePreset');
    const applyButton = document.getElementById('motionScheduleApply');
    const saveButton = document.getElementById('motionScheduleSave');
    const statusEl = document.getElementById('motionScheduleStatus');
    const saveUrl = scheduleContainer.dataset.saveUrl;
    let slots = scheduleGrid ? Array.from(scheduleGrid.querySelectorAll('.motion-schedule-slot')) : [];
    const slotCount = scheduleData.length;
    let statusTimeout = null;
    let dirty = false;
    let selectedSlot = 0;
    const beforeUnloadHandler = (event) => {
      event.preventDefault();
      event.returnValue = '';
    };

    presetNames[''] = 'No Motion';

    if (scheduleGrid && slots.length < slotCount) {
      for (let i = slots.length; i < slotCount; i++) {
        const slot = document.createElement('div');
        slot.className = 'motion-schedule-slot';
        slot.dataset.slot = String(i);
        const hour = document.createElement('span');
        hour.className = 'motion-schedule-hour';
        slot.appendChild(hour);
        const label = document.createElement('span');
        label.className = 'motion-schedule-label';
        slot.appendChild(label);
        scheduleGrid.appendChild(slot);
      }
      slots = Array.from(scheduleGrid.querySelectorAll('.motion-schedule-slot'));
    }

    slots.forEach((slot) => {
      if (!slot.querySelector('.motion-schedule-hour')) {
        const hour = document.createElement('span');
        hour.className = 'motion-schedule-hour';
        slot.appendChild(hour);
      }
      if (!slot.querySelector('.motion-schedule-label')) {
        const label = document.createElement('span');
        label.className = 'motion-schedule-label';
        slot.appendChild(label);
      }
    });

    const minutesForIndex = (index) => {
      const normalized = ((index % slotCount) + slotCount) % slotCount;
      return normalized * slotMinutes;
    };

    const formatTime = (minutes) => {
      const hour = Math.floor(minutes / 60) % 24;
      const minute = minutes % 60;
      const suffix = hour >= 12 ? 'p' : 'a';
      const displayHour = hour % 12 || 12;
      const minuteText = minute ? `:${String(minute).padStart(2, '0')}` : '';
      return `${displayHour}${minuteText}${suffix}`;
    };

    const formatLabel = (index) => {
      const minutes = minutesForIndex(index);
      return formatTime(minutes);
    };

    const formatRange = (index) => {
      const start = minutesForIndex(index);
      const end = minutesForIndex(index + 1);
      return `${formatTime(start)} – ${formatTime(end)}`;
    };

    const pickTextColor = (color) => {
      if (!color || !color.startsWith('#')) {
        return '#f8fafc';
      }
      let hex = color.slice(1);
      if (hex.length === 3) {
        hex = hex.split('').map((ch) => ch + ch).join('');
      }
      const r = parseInt(hex.slice(0, 2), 16);
      const g = parseInt(hex.slice(2, 4), 16);
      const b = parseInt(hex.slice(4, 6), 16);
      const brightness = (r * 299 + g * 587 + b * 114) / 1000;
      return brightness > 155 ? '#0f172a' : '#f8fafc';
    };

    const updateSlotHighlight = () => {
      slots.forEach((slot, idx) => {
        slot.classList.toggle('motion-schedule-slot--selected', idx === selectedSlot);
      });
    };

    const renderSchedule = () => {
      slots.forEach((slot, idx) => {
        const presetId = scheduleData[idx] || '';
        const color = presetColors[presetId] || noMotionColor;
        slot.style.setProperty('--slot-color', color);
        slot.style.setProperty('--slot-text', pickTextColor(color));
        slot.dataset.preset = presetId;
        const rangeLabel = formatRange(idx);
        const hourEl = slot.querySelector('.motion-schedule-hour');
        if (hourEl) {
          hourEl.textContent = rangeLabel;
        }
        const labelEl = slot.querySelector('.motion-schedule-label');
        const presetName = presetNames[presetId] || presetId || 'No Motion';
        if (labelEl) {
          labelEl.textContent = presetName;
        }
        slot.setAttribute('title', `${rangeLabel} – ${presetName}`);
        slot.setAttribute('aria-label', `${rangeLabel} – ${presetName}`);
        slot.classList.toggle('motion-schedule-slot--empty', !presetId);
      });
      updateSlotHighlight();
    };

    const updateSaveState = () => {
      if (!saveButton) return;
      saveButton.disabled = !dirty;
      saveButton.classList.toggle('motion-button--dirty', dirty);
      if (dirty) {
        window.addEventListener('beforeunload', beforeUnloadHandler);
      } else {
        window.removeEventListener('beforeunload', beforeUnloadHandler);
      }
    };

    const populateSelects = () => {
      if (!startSelect || !endSelect) return;
      startSelect.innerHTML = '';
      endSelect.innerHTML = '';
      for (let i = 0; i < slotCount; i++) {
        const opt = document.createElement('option');
        opt.value = String(i);
        opt.textContent = formatLabel(i);
        startSelect.appendChild(opt);
      }
      for (let i = 1; i <= slotCount; i++) {
        const opt = document.createElement('option');
        opt.value = String(i);
        opt.textContent = formatLabel(i % slotCount);
        endSelect.appendChild(opt);
      }
      startSelect.value = '0';
      endSelect.value = '1';
    };

    const updateEndOptions = () => {
      if (!endSelect || !startSelect) return;
      const start = parseInt(startSelect.value, 10);
      Array.from(endSelect.options).forEach((opt) => {
        const val = parseInt(opt.value, 10);
        opt.disabled = Number.isInteger(val) && val <= start;
      });
      if (parseInt(endSelect.value, 10) <= start) {
        endSelect.value = String(Math.min(slotCount, start + 1));
      }
    };

    const updateSelection = (index) => {
      if (!Number.isInteger(index)) {
        index = 0;
      }
      selectedSlot = ((index % slotCount) + slotCount) % slotCount;
      if (startSelect) {
        startSelect.value = String(selectedSlot);
      }
      updateEndOptions();
      if (endSelect) {
        const currentEnd = parseInt(endSelect.value, 10);
        if (!Number.isInteger(currentEnd) || currentEnd <= selectedSlot) {
          endSelect.value = String(Math.min(slotCount, selectedSlot + 1));
        }
      }
      if (presetSelect) {
        const presetId = scheduleData[selectedSlot] || '';
        const hasOption = Array.from(presetSelect.options).some((opt) => opt.value === presetId);
        presetSelect.value = hasOption ? presetId : '';
      }
      updateSlotHighlight();
    };

    const rebuildPresetSelectOptions = (list) => {
      if (!presetSelect) return;
      const previous = presetSelect.value;
      presetSelect.innerHTML = '';
      const defaultOption = document.createElement('option');
      defaultOption.value = '';
      defaultOption.textContent = 'No Motion';
      presetSelect.appendChild(defaultOption);
      if (Array.isArray(list)) {
        list.forEach((preset) => {
          if (!preset || preset.id === undefined || preset.id === null) {
            return;
          }
          const id = String(preset.id);
          const name = preset.name ? String(preset.name) : id;
          const opt = document.createElement('option');
          opt.value = id;
          opt.textContent = name;
          presetSelect.appendChild(opt);
        });
      }
      if (Array.from(presetSelect.options).some((opt) => opt.value === previous)) {
        presetSelect.value = previous;
      } else {
        presetSelect.value = '';
      }
    };

    const updateMotionPresets = (list) => {
      const normalized = [];
      if (Array.isArray(list)) {
        list.forEach((preset) => {
          if (!preset || preset.id === undefined || preset.id === null) {
            return;
          }
          const id = String(preset.id);
          const name = preset.name ? String(preset.name) : id;
          normalized.push({ id, name });
        });
      }
      const required = new Set(
        Array.isArray(scheduleData)
          ? scheduleData.filter((value) => value !== null && value !== undefined && value !== '')
          : []
      );
      const newNames = { '': 'No Motion' };
      normalized.forEach((preset) => {
        newNames[preset.id] = preset.name;
      });
      required.forEach((id) => {
        if (!newNames[id]) {
          const fallback = presetNames[id] || String(id);
          newNames[id] = fallback;
        }
      });
      const newColors = {};
      const usedColors = new Set();
      normalized.forEach((preset, index) => {
        const existing = presetColors[preset.id];
        if (existing) {
          newColors[preset.id] = existing;
          usedColors.add(existing);
          return;
        }
        let assigned = null;
        for (let offset = 0; offset < palette.length; offset++) {
          const candidate = palette[(index + offset) % palette.length];
          if (!usedColors.has(candidate)) {
            assigned = candidate;
            break;
          }
        }
        if (!assigned) {
          assigned = palette[index % palette.length];
        }
        newColors[preset.id] = assigned;
        usedColors.add(assigned);
      });
      required.forEach((id) => {
        if (!newColors[id] && presetColors[id]) {
          newColors[id] = presetColors[id];
          usedColors.add(presetColors[id]);
          if (!newNames[id]) {
            newNames[id] = presetNames[id] || String(id);
          }
        }
      });
      presetNames = newNames;
      presetColors = newColors;
      rebuildPresetSelectOptions(normalized);
      renderSchedule();
      updateSelection(selectedSlot);
    };

    document.addEventListener('ultralights:presets-changed', (event) => {
      if (!event || !event.detail || !Array.isArray(event.detail.presets)) {
        return;
      }
      updateMotionPresets(event.detail.presets);
    });

    if (window.UltraLights && Array.isArray(window.UltraLights.presets)) {
      updateMotionPresets(window.UltraLights.presets);
    }

    const setStatus = (message, cls) => {
      if (!statusEl) return;
      if (statusTimeout) {
        clearTimeout(statusTimeout);
        statusTimeout = null;
      }
      if (!message) {
        statusEl.textContent = '';
        statusEl.className = 'text-sm mt-3 opacity-80';
        return;
      }
      statusEl.textContent = message;
      statusEl.className = `text-sm mt-3 ${cls}`;
    };

    const markDirty = () => {
      if (!dirty) {
        dirty = true;
        updateSaveState();
      }
      setStatus('Unsaved changes – click save to persist.', 'text-amber-300');
    };

    const clearStatus = () => {
      dirty = false;
      updateSaveState();
      setStatus('Schedule saved ✓', 'text-emerald-300');
      statusTimeout = setTimeout(() => setStatus('', ''), 2200);
    };

    const showError = (message) => {
      setStatus(message, 'text-rose-300');
    };

    populateSelects();
    updateEndOptions();
    renderSchedule();
    updateSelection(0);
    updateSaveState();
    setStatus('', '');

    if (startSelect) {
      startSelect.addEventListener('change', () => {
        const startIdx = parseInt(startSelect.value, 10);
        updateSelection(Number.isInteger(startIdx) ? startIdx : 0);
      });
    }
    if (endSelect) {
      endSelect.addEventListener('change', () => {
        updateEndOptions();
      });
    }
    slots.forEach((slot) => {
      slot.addEventListener('click', () => {
        const idx = parseInt(slot.dataset.slot || '', 10);
        if (Number.isInteger(idx)) {
          updateSelection(idx);
        }
      });
    });
    if (applyButton) {
      applyButton.addEventListener('click', () => {
        const start = parseInt(startSelect ? startSelect.value : '0', 10);
        const end = parseInt(endSelect ? endSelect.value : '0', 10);
        if (!Number.isInteger(start) || !Number.isInteger(end)) {
          showError('Select a valid time range.');
          return;
        }
        if (end <= start) {
          showError('End time must be after start time.');
          return;
        }
        const presetId = presetSelect ? presetSelect.value : '';
        for (let idx = start; idx < end; idx++) {
          scheduleData[idx] = presetId || null;
        }
        renderSchedule();
        updateSelection(start);
        markDirty();
      });
    }
    if (saveButton) {
      saveButton.addEventListener('click', async () => {
        if (!dirty) {
          setStatus('No changes to save.', 'text-slate-200 opacity-80');
          statusTimeout = setTimeout(() => setStatus('', ''), 1800);
          return;
        }
        setStatus('Saving schedule...', 'text-slate-200 opacity-80');
        saveButton.disabled = true;
        try {
          const response = await fetch(saveUrl, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({schedule: scheduleData}),
          });
          let data = null;
          try {
            data = await response.json();
          } catch (err) {
            data = null;
          }
          if (!response.ok) {
            const detail = data && data.detail ? data.detail : 'Failed to save schedule.';
            throw new Error(detail);
          }
          if (data && Array.isArray(data.schedule)) {
            for (let i = 0; i < slotCount; i++) {
              scheduleData[i] = data.schedule[i];
            }
          }
          renderSchedule();
          updateSelection(selectedSlot);
          clearStatus();
        } catch (err) {
          const message = err instanceof Error ? err.message : 'Failed to save schedule.';
          showError(message);
          dirty = true;
          updateSaveState();
        }
      });
    }
  }

  const immunityContainer = document.getElementById('motionImmunity');
  if (immunityContainer) {
    const fetchUrl = immunityContainer.dataset.fetchUrl || '';
    const saveUrl = immunityContainer.dataset.saveUrl || fetchUrl;
    const statusEl = immunityContainer.querySelector('.motion-immunity-status');
    const checkboxes = Array.from(
      immunityContainer.querySelectorAll('.motion-immunity-checkbox')
    );
    const saveButton = immunityContainer.querySelector('.motion-immunity-save');
    const statusClasses = {
      base: 'motion-immunity-status text-sm opacity-80 mb-3',
      info: 'motion-immunity-status text-sm text-slate-200 opacity-80 mb-3',
      success: 'motion-immunity-status text-sm text-emerald-300 mb-3',
      error: 'motion-immunity-status text-sm text-rose-300 mb-3',
    };
    let statusTimer = null;

    const setStatus = (message, tone = 'base', autoClear = false) => {
      if (!statusEl) return;
      if (statusTimer) {
        clearTimeout(statusTimer);
        statusTimer = null;
      }
      if (!message) {
        statusEl.textContent = '';
        statusEl.className = statusClasses.base;
        return;
      }
      const cls = statusClasses[tone] || statusClasses.base;
      statusEl.className = cls;
      statusEl.textContent = message;
      if (autoClear) {
        statusTimer = setTimeout(() => {
          statusEl.textContent = '';
          statusEl.className = statusClasses.base;
          statusTimer = null;
        }, 2200);
      }
    };

    const normalizeList = (values) => {
      const clean = [];
      const seen = new Set();
      if (Array.isArray(values)) {
        values.forEach((value) => {
          const text = value === undefined || value === null ? '' : String(value).trim();
          if (text && !seen.has(text)) {
            seen.add(text);
            clean.push(text);
          }
        });
      }
      return clean;
    };

    const applyImmuneState = (values) => {
      const immuneSet = new Set(values);
      checkboxes.forEach((checkbox) => {
        const nodeId = String(checkbox.value || '').trim();
        checkbox.checked = immuneSet.has(nodeId);
      });
    };

    const collectSelected = () => {
      const selected = [];
      const seen = new Set();
      checkboxes.forEach((checkbox) => {
        if (!checkbox.checked) {
          return;
        }
        const value = String(checkbox.value || '').trim();
        if (value && !seen.has(value)) {
          seen.add(value);
          selected.push(value);
        }
      });
      return selected;
    };

    const loadImmunity = async () => {
      if (!fetchUrl) {
        return;
      }
      if (checkboxes.length) {
        setStatus('Loading immunity...', 'info');
      }
      try {
        const response = await fetch(fetchUrl);
        let data = null;
        try {
          data = await response.json();
        } catch (err) {
          data = null;
        }
        if (!response.ok) {
          const detail = data && (data.detail || data.error || data.message || data.reason);
          const message = detail ? String(detail) : `Request failed (${response.status})`;
          throw new Error(message);
        }
        const immune = normalizeList(data && data.immune);
        applyImmuneState(immune);
        setStatus('', 'base');
      } catch (err) {
        const message = err instanceof Error ? err.message : 'Failed to load immunity.';
        setStatus(`Failed to load immunity: ${message}`, 'error');
      }
    };

    if (saveButton) {
      if (!checkboxes.length || !saveUrl) {
        saveButton.disabled = true;
      }
      saveButton.addEventListener('click', async () => {
        if (!saveUrl) {
          setStatus('Saving immunity is not available.', 'error');
          return;
        }
        const selected = collectSelected();
        try {
          saveButton.disabled = true;
          setStatus('Saving immunity...', 'info');
          const response = await fetch(saveUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ immune: selected }),
          });
          let data = null;
          try {
            data = await response.json();
          } catch (err) {
            data = null;
          }
          if (!response.ok) {
            const detail = data && (data.detail || data.error || data.message || data.reason);
            const message = detail ? String(detail) : `Request failed (${response.status})`;
            throw new Error(message);
          }
          const immune = normalizeList(data && data.immune);
          applyImmuneState(immune);
          setStatus('Immunity saved ✓', 'success', true);
        } catch (err) {
          const message = err instanceof Error ? err.message : 'Failed to save immunity.';
          setStatus(`Failed to save immunity: ${message}`, 'error');
        } finally {
          saveButton.disabled = !checkboxes.length || !saveUrl;
        }
      });
    }

    if (checkboxes.length) {
      checkboxes.forEach((checkbox) => {
        checkbox.addEventListener('change', () => {
          setStatus('Unsaved changes – click save to persist.', 'info');
        });
      });
    }

    loadImmunity();
  }

  const timerSliders = document.querySelectorAll('.motion-timer-slider');
  if (timerSliders.length) {
    const fmtTime = (sec) => {
      if (!Number.isInteger(sec)) return '';
      if (sec < 60) return `${sec}s`;
      const m = Math.floor(sec / 60);
      const s = sec % 60;
      return s ? `${m}m ${s}s` : `${m}m`;
    };
    timerSliders.forEach((slider) => {
      const container = slider.closest('.motion-timer');
      const label = container ? container.querySelector('.motion-timer-label') : null;
      const nodeId = slider.dataset.node;
      if (!nodeId) {
        return;
      }
      const enabled = slider.dataset.enabled !== 'false';
      const updateTimer = () => {
        if (!label) return;
        const duration = parseInt(slider.value, 10);
        label.textContent = fmtTime(Number.isInteger(duration) ? duration : 0);
      };
      slider.addEventListener('input', updateTimer);
      slider.addEventListener('change', async () => {
        const duration = parseInt(slider.value, 10);
        if (!Number.isInteger(duration)) {
          return;
        }
        const res = await fetch(`/api/node/${nodeId}/motion`, {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({enabled, duration})
        });
        if(!res.ok) alert('Failed to update timer');
      });
      updateTimer();
    });
  }
})();
{% endif %}
</script>
{% endblock %}
