{% extends "base.html" %}
{% block content %}
<div class="mb-6 flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
  <h2 class="text-2xl font-semibold">Rooms</h2>
  <div class="flex items-center gap-2">
    {% if can_manage_house %}
    <a href="/admin/house/{{ house_public_id }}" class="px-4 py-2 pill bg-slate-700 hover:bg-slate-600">Admin Panel</a>
    <button id="addRoom" class="w-12 h-12 flex items-center justify-center text-2xl rounded-full bg-indigo-600 hover:bg-indigo-500">+</button>
    {% endif %}
  </div>
</div>
{% if house.rooms %}
<div class="grid md:grid-cols-3 gap-4" data-room-grid data-can-manage="{{ 'true' if can_manage_house else 'false' }}">
  {% for r in house.rooms %}
  <a href="/house/{{ house_public_id }}/room/{{ r.id }}" data-room-card data-room-id="{{ r.id }}" class="glass rounded-xl p-4 block hover:ring-2 hover:ring-indigo-400{% if can_manage_house %} cursor-move{% endif %}">
    <div class="text-xl font-semibold">{{ r.name }}</div>
    <div class="opacity-60 text-xs mt-2">ID: {{ r.id }}</div>
    <div class="text-sm mt-2">{{ r.nodes|length }} node{% if r.nodes|length != 1 %}s{% endif %}</div>
  </a>
  {% endfor %}
</div>
{% else %}
<div class="glass rounded-xl p-6 text-center text-sm opacity-70">
  No rooms available.
</div>
{% endif %}
<script>
const addRoomButton = document.getElementById('addRoom');
if(addRoomButton){
  addRoomButton.onclick = async () => {
    const name = prompt('New room name');
    if(!name) return;
    const res = await fetch('/api/house/{{ house_public_id }}/rooms', {
      method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name})
    });
    if(res.ok) location.reload(); else alert('Failed to add room');
  };
}

const grid = document.querySelector('[data-room-grid]');
if(grid && grid.dataset.canManage === 'true'){
  const cards = grid.querySelectorAll('[data-room-card]');
  let dragging = null;
  let dropOccurred = false;
  let saving = false;

  const persistOrder = async () => {
    const order = Array.from(grid.querySelectorAll('[data-room-card]'))
      .map(card => card.dataset.roomId)
      .filter(id => !!id);
    if(order.length <= 1){
      return;
    }
    try {
      const res = await fetch('/api/house/{{ house_public_id }}/rooms/reorder', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({order})
      });
      if(!res.ok){
        throw new Error(await res.text());
      }
    } catch (err) {
      console.error('Failed to save room order', err);
      alert('Failed to save room order. Reloading previous layout.');
      location.reload();
    }
  };

  cards.forEach(card => {
    card.setAttribute('draggable', 'true');
    card.setAttribute('aria-grabbed', 'false');
    card.addEventListener('dragstart', event => {
      dragging = card;
      dropOccurred = false;
      card.classList.add('opacity-60', 'dragging');
      card.setAttribute('aria-grabbed', 'true');
      event.dataTransfer.effectAllowed = 'move';
      event.dataTransfer.setData('text/plain', card.dataset.roomId || '');
    });
    card.addEventListener('dragend', async () => {
      card.classList.remove('opacity-60', 'dragging');
      card.setAttribute('aria-grabbed', 'false');
      const shouldSave = dropOccurred;
      dropOccurred = false;
      dragging = null;
      if(shouldSave && !saving){
        saving = true;
        await persistOrder();
        saving = false;
      }
    });
  });

  grid.addEventListener('dragover', event => {
    if(!dragging) return;
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
    const targetElement = event.target instanceof Element ? event.target.closest('[data-room-card]') : null;
    if(!targetElement){
      if(dragging && dragging !== grid.lastElementChild){
        grid.appendChild(dragging);
      }
      return;
    }
    if(targetElement === dragging){
      return;
    }
    const rect = targetElement.getBoundingClientRect();
    const isAfter = event.clientY > rect.top + rect.height / 2;
    if(isAfter){
      targetElement.after(dragging);
    } else {
      targetElement.before(dragging);
    }
  });

  grid.addEventListener('drop', event => {
    if(!dragging) return;
    event.preventDefault();
    dropOccurred = true;
  });
}
</script>
{% endblock %}
