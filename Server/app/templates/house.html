{% extends "base.html" %}
{% block content %}
<div class="mb-6 flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
  <h2 class="text-2xl font-semibold">Rooms</h2>
  <div class="flex items-center gap-2">
    {% if can_manage_house %}
    <a href="/admin/house/{{ house_public_id }}" class="px-4 py-2 pill bg-slate-700 hover:bg-slate-600">Admin Panel</a>
    <button id="addRoom" class="w-12 h-12 flex items-center justify-center text-2xl rounded-full bg-indigo-600 hover:bg-indigo-500">+</button>
    {% endif %}
  </div>
</div>
{% if can_manage_house and house_pending_nodes %}
<section class="glass rounded-xl p-6 mb-6" data-node-assignment data-house-id="{{ house_public_id }}">
  <div class="flex flex-col gap-2 sm:flex-row sm:items-start sm:justify-between">
    <div>
      <h3 class="text-xl font-semibold">Unassigned Nodes</h3>
      <p class="text-sm opacity-70">Place captured nodes into rooms and give them a friendly name.</p>
    </div>
  </div>
  {% if house_room_options %}
  <div class="mt-4 grid gap-4" data-node-assignment-list>
    {% for node in house_pending_nodes %}
    <div class="glass rounded-lg p-4 border border-slate-700/60" data-node-entry="{{ node.id }}">
      <div class="flex flex-wrap items-baseline justify-between gap-2">
        <div>
          <div class="text-sm font-semibold uppercase tracking-wide opacity-70">Node</div>
          <div class="text-lg font-semibold">{{ node.name }}</div>
          <div class="text-xs opacity-60">ID: {{ node.id }}</div>
        </div>
        <div class="text-xs opacity-60 break-all">Download ID: {{ node.downloadId }}</div>
      </div>
      <div class="mt-4 grid gap-3 md:grid-cols-2">
        <label class="block text-sm font-semibold">
          <span>Display name</span>
          <input type="text" class="mt-1 w-full bg-slate-900/60 border border-slate-700 rounded px-3 py-2" value="{{ node.name }}" data-node-name>
        </label>
        <label class="block text-sm font-semibold">
          <span>Room</span>
          <select class="mt-1 w-full bg-slate-900/60 border border-slate-700 rounded px-3 py-2" data-node-room>
            {% for room in house_room_options %}
            <option value="{{ room.id }}">{{ room.name }}</option>
            {% endfor %}
          </select>
        </label>
      </div>
      <div class="mt-4 flex flex-wrap items-center gap-3">
        <button type="button" class="px-4 py-2 pill bg-indigo-600 hover:bg-indigo-500 text-sm font-semibold" data-node-assign>Assign Node</button>
        <div class="text-sm opacity-70" data-node-status role="status" aria-live="polite"></div>
      </div>
    </div>
    {% endfor %}
  </div>
  {% else %}
  <div class="mt-4 text-sm opacity-70">
    Create a room before assigning nodes.
  </div>
  {% endif %}
</section>
{% endif %}
{% if house.rooms %}
<div class="grid md:grid-cols-3 gap-4" data-room-grid data-can-manage="{{ 'true' if can_manage_house else 'false' }}">
  {% for r in house.rooms %}
  <a href="/house/{{ house_public_id }}/room/{{ r.id }}" data-room-card data-room-id="{{ r.id }}" class="glass rounded-xl p-4 block hover:ring-2 hover:ring-indigo-400 animated-border{% if can_manage_house %} cursor-move{% endif %}">
    <div class="text-xl font-semibold">{{ r.name }}</div>
    <div class="opacity-60 text-xs mt-2">ID: {{ r.id }}</div>
    <div class="text-sm mt-2">{{ r.nodes|length }} node{% if r.nodes|length != 1 %}s{% endif %}</div>
  </a>
  {% endfor %}
</div>
{% else %}
<div class="glass rounded-xl p-6 text-center text-sm opacity-70">
  No rooms available.
</div>
{% endif %}
<script>
const addRoomButton = document.getElementById('addRoom');
if(addRoomButton){
  addRoomButton.onclick = async () => {
    const name = prompt('New room name');
    if(!name) return;
    const res = await fetch('/api/house/{{ house_public_id }}/rooms', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      credentials: 'same-origin',
      body: JSON.stringify({name})
    });
    if(res.ok) location.reload(); else alert('Failed to add room');
  };
}

const grid = document.querySelector('[data-room-grid]');
if(grid && grid.dataset.canManage === 'true'){
  const cards = grid.querySelectorAll('[data-room-card]');
  let dragging = null;
  let dropOccurred = false;
  let saving = false;

  const persistOrder = async () => {
    const order = Array.from(grid.querySelectorAll('[data-room-card]'))
      .map(card => card.dataset.roomId)
      .filter(id => !!id);
    if(order.length <= 1){
      return;
    }
    try {
      const res = await fetch('/api/house/{{ house_public_id }}/rooms/reorder', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        credentials: 'same-origin',
        body: JSON.stringify({order})
      });
      if(!res.ok){
        throw new Error(await res.text());
      }
    } catch (err) {
      console.error('Failed to save room order', err);
      alert('Failed to save room order. Reloading previous layout.');
      location.reload();
    }
  };

  cards.forEach(card => {
    card.setAttribute('draggable', 'true');
    card.setAttribute('aria-grabbed', 'false');
    card.addEventListener('dragstart', event => {
      dragging = card;
      dropOccurred = false;
      card.classList.add('opacity-60', 'dragging');
      card.setAttribute('aria-grabbed', 'true');
      event.dataTransfer.effectAllowed = 'move';
      event.dataTransfer.setData('text/plain', card.dataset.roomId || '');
    });
    card.addEventListener('dragend', async () => {
      card.classList.remove('opacity-60', 'dragging');
      card.setAttribute('aria-grabbed', 'false');
      const shouldSave = dropOccurred;
      dropOccurred = false;
      dragging = null;
      if(shouldSave && !saving){
        saving = true;
        await persistOrder();
        saving = false;
      }
    });
  });

  grid.addEventListener('dragover', event => {
    if(!dragging) return;
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
    const targetElement = event.target instanceof Element ? event.target.closest('[data-room-card]') : null;
    if(!targetElement){
      if(dragging && dragging !== grid.lastElementChild){
        grid.appendChild(dragging);
      }
      return;
    }
    if(targetElement === dragging){
      return;
    }
    const rect = targetElement.getBoundingClientRect();
    const isAfter = event.clientY > rect.top + rect.height / 2;
    if(isAfter){
      targetElement.after(dragging);
    } else {
      targetElement.before(dragging);
    }
  });

  grid.addEventListener('drop', event => {
    if(!dragging) return;
    event.preventDefault();
    dropOccurred = true;
  });
}

const assignmentSection = document.querySelector('[data-node-assignment]');
if (assignmentSection) {
  const houseId = assignmentSection.dataset.houseId;
  assignmentSection.querySelectorAll('[data-node-assign]').forEach((button) => {
    button.addEventListener('click', async () => {
      if (!houseId || button.disabled) {
        return;
      }
      const entry = button.closest('[data-node-entry]');
      if (!entry) {
        return;
      }
      const nodeId = entry.dataset.nodeEntry;
      const nameInput = entry.querySelector('[data-node-name]');
      const roomSelect = entry.querySelector('[data-node-room]');
      const statusEl = entry.querySelector('[data-node-status]');
      if (!nodeId || !roomSelect || !roomSelect.value) {
        if (statusEl) {
          statusEl.textContent = 'Select a room before assigning.';
        }
        return;
      }
      const payload = {
        nodeId,
        roomId: roomSelect.value,
        name: nameInput ? nameInput.value.trim() : undefined,
      };
      button.disabled = true;
      button.textContent = 'Assigningâ€¦';
      if (statusEl) {
        statusEl.textContent = '';
      }
      try {
        const res = await fetch(`/api/house/${encodeURIComponent(houseId)}/nodes/assign`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'same-origin',
          body: JSON.stringify(payload),
        });
        if (!res.ok) {
          const message = await res.text();
          throw new Error(message || `HTTP ${res.status}`);
        }
        location.reload();
      } catch (err) {
        console.error('Failed to assign node', err);
        if (statusEl) {
          statusEl.textContent = err instanceof Error ? err.message : 'Failed to assign node.';
        } else {
          alert('Failed to assign node.');
        }
      } finally {
        button.disabled = false;
        button.textContent = 'Assign Node';
      }
    });
  });
}
</script>
{% endblock %}
