<section class="glass rounded-2xl p-6" data-module-root>
  <header class="mb-4">
    <h3 class="text-lg font-semibold">White Channels</h3>
    <p class="mt-2 text-sm text-slate-400 hidden" data-module-empty-message>
      No white channels reported.
    </p>
  </header>
  <div class="flex flex-col gap-4" data-channel-list></div>
  <template data-channel-template>
    <article
      class="rounded-xl border border-slate-800/60 bg-slate-900/40 p-4 space-y-4"
      data-channel-card
    >
      <header class="flex items-center justify-between">
        <h4 class="text-base font-semibold">
          Channel <span data-role="channel-label"></span>
        </h4>
      </header>
      <div class="space-y-2">
        <label class="text-xs opacity-70">Effect</label>
        <select
          data-role="effect"
          class="w-full p-1 bg-slate-900 rounded border border-slate-700"
        ></select>
      </div>
      <div class="space-y-2" data-role="params"></div>
      <div class="space-y-2">
        <div class="flex items-center justify-between">
          <label class="text-xs opacity-70">Brightness</label>
          <button
            type="button"
            class="text-xl leading-none"
            data-role="lock"
            title="Lock brightness"
            aria-pressed="false"
          >
            ðŸ”“
          </button>
        </div>
        <input
          type="range"
          min="0"
          max="255"
          value="255"
          data-role="brightness"
          class="w-full"
        />
      </div>
      <div class="flex gap-2">
        <button
          type="button"
          class="px-4 py-2 pill bg-green-600 hover:bg-green-500 text-white"
          data-role="on"
        >
          On
        </button>
        <button
          type="button"
          class="px-4 py-2 pill bg-red-600 hover:bg-red-500 text-white"
          data-role="off"
        >
          Off
        </button>
      </div>
    </article>
  </template>
</section>
<script type="module">
import { renderParams, collectParams } from '/static/params.js';

const WHITE_PARAM_DEFS = {{ white_param_defs|tojson }};
const WHITE_EFFECTS = {{ white_effects|tojson }};
const MODULE_KEY = 'white';
const NODE_ID = {{ node.id|tojson }};
const MANAGER_REF = Symbol('white-module-manager');

function toChannelValue(channel) {
  const num = Number(channel);
  return Number.isNaN(num) ? String(channel) : num;
}

function normalizeChannelId(value) {
  if (value === null || value === undefined) return null;
  const str = String(value).trim();
  return str === '' ? null : str;
}

class WhiteModuleManager {
  constructor(host) {
    this.host = host;
    this.listEl = host.querySelector('[data-channel-list]');
    this.template = host.querySelector('template[data-channel-template]');
    this.emptyMessage = host.querySelector('[data-module-empty-message]');
    this.defaultEmptyMessage = this.emptyMessage ? this.emptyMessage.textContent : '';
    this.controllers = new Map();
    this.effectOptions = Array.isArray(WHITE_EFFECTS)
      ? WHITE_EFFECTS.filter((value) => typeof value === 'string' && value.trim())
      : [];
    this.ready = Boolean(this.listEl && this.template);
    if (!this.ready) {
      console.warn('White module template missing host container');
    }
  }

  getDefaultEffect() {
    if (this.effectOptions.includes('solid')) return 'solid';
    return this.effectOptions[0] || '';
  }

  getParamDefs(effect) {
    return WHITE_PARAM_DEFS && WHITE_PARAM_DEFS[effect] ? WHITE_PARAM_DEFS[effect] : [];
  }

  post(path, body) {
    return fetch(path, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    }).then((res) => {
      if (!res.ok) {
        throw new Error(`Request failed with status ${res.status}`);
      }
      return res;
    });
  }

  getLimit(channel) {
    const data = window.nodeBrightnessLimits;
    if (!data) return null;
    const moduleData = data[MODULE_KEY];
    if (!moduleData) return null;
    const value = moduleData[String(channel)];
    return typeof value === 'number' && !Number.isNaN(value) ? value : null;
  }

  cacheLimit(channel, limit) {
    const data = window.nodeBrightnessLimits || (window.nodeBrightnessLimits = {});
    const key = String(channel);
    if (limit === null || limit === undefined) {
      const moduleData = data[MODULE_KEY];
      if (moduleData) {
        delete moduleData[key];
        if (Object.keys(moduleData).length === 0) {
          delete data[MODULE_KEY];
        }
      }
      return;
    }
    const moduleData = data[MODULE_KEY] || (data[MODULE_KEY] = {});
    moduleData[key] = limit;
  }

  async persistLimit(channel, limit) {
    const payload = { channel: toChannelValue(channel), limit };
    try {
      const res = await this.post(`/api/node/${encodeURIComponent(NODE_ID)}/white/brightness-limit`, payload);
      let response = null;
      try {
        response = await res.json();
      } catch (err) {
        response = null;
      }
      if (response && response.limit !== undefined) {
        const value = response.limit;
        if (typeof value === 'number' && !Number.isNaN(value)) {
          const clamped = Math.max(0, Math.min(255, Math.round(value)));
          this.cacheLimit(channel, clamped);
          return clamped;
        }
        this.cacheLimit(channel, null);
        return null;
      }
      if (typeof limit === 'number' && !Number.isNaN(limit)) {
        const clamped = Math.max(0, Math.min(255, Math.round(limit)));
        this.cacheLimit(channel, clamped);
        return clamped;
      }
      this.cacheLimit(channel, null);
      return null;
    } catch (err) {
      console.error(err);
      alert('Request failed');
      return this.getLimit(channel);
    }
  }

  createStateFromEntry(entry) {
    const state = {
      effect: this.getDefaultEffect(),
      brightness: 255,
      paramCache: {},
    };
    if (entry && typeof entry === 'object') {
      if (typeof entry.effect === 'string' && entry.effect.trim()) {
        state.effect = entry.effect.trim();
      }
      if (typeof entry.brightness === 'number' && !Number.isNaN(entry.brightness)) {
        state.brightness = Math.max(0, Math.min(255, Math.round(entry.brightness)));
      }
      if (Array.isArray(entry.params) && entry.params.length) {
        state.paramCache[state.effect] = entry.params.slice();
      }
    }
    if (!state.effect) {
      state.effect = this.getDefaultEffect();
    }
    if (!state.paramCache) {
      state.paramCache = {};
    }
    return state;
  }

  clearControllers() {
    this.controllers.forEach((controller) => controller.destroy());
    this.controllers.clear();
    if (this.listEl) {
      this.listEl.innerHTML = '';
    }
  }

  updateEmptyState(hasChannels, message) {
    if (!this.emptyMessage) return;
    const text = typeof message === 'string' && message.trim() ? message : this.defaultEmptyMessage;
    this.emptyMessage.textContent = text;
    this.emptyMessage.classList.toggle('hidden', hasChannels);
  }

  ensureController(channel) {
    const key = String(channel);
    let controller = this.controllers.get(key);
    if (!controller) {
      controller = new WhiteChannelController(this, key);
      if (controller.root) {
        this.controllers.set(key, controller);
      }
    }
    return controller;
  }

  update(payload = {}) {
    if (!this.ready) return;
    if (payload.available === false) {
      this.clearControllers();
      this.updateEmptyState(false, payload.message);
      return;
    }
    const stateEntries = payload.state && typeof payload.state === 'object' ? payload.state : {};
    const providedChannels = Array.isArray(payload.channels) ? payload.channels : null;
    const channelIds = providedChannels && providedChannels.length
      ? providedChannels
      : Object.keys(stateEntries || {});
    const normalized = channelIds
      .map(normalizeChannelId)
      .filter((value) => value !== null);
    const sorted = normalized.sort((a, b) => {
      const numA = Number(a);
      const numB = Number(b);
      const aIsNum = !Number.isNaN(numA);
      const bIsNum = !Number.isNaN(numB);
      if (aIsNum && bIsNum) return numA - numB;
      if (aIsNum) return -1;
      if (bIsNum) return 1;
      return a.localeCompare(b);
    });
    const seen = new Set();
    sorted.forEach((channelId) => {
      const controller = this.ensureController(channelId);
      if (!controller) return;
      seen.add(channelId);
      const entry =
        stateEntries[channelId] !== undefined
          ? stateEntries[channelId]
          : stateEntries[String(Number(channelId))];
      controller.applyState(entry);
      const limits = payload.limits && typeof payload.limits === 'object' ? payload.limits : {};
      const limitValue = limits && limits[channelId] !== undefined ? limits[channelId] : limits[String(Number(channelId))];
      controller.applyLimit(limitValue, { silent: true });
      if (this.listEl && controller.root.parentElement !== this.listEl) {
        this.listEl.appendChild(controller.root);
      } else if (this.listEl) {
        this.listEl.appendChild(controller.root);
      }
    });
    Array.from(this.controllers.keys()).forEach((key) => {
      if (!seen.has(key)) {
        const controller = this.controllers.get(key);
        if (controller) {
          controller.destroy();
        }
        this.controllers.delete(key);
      }
    });
    this.updateEmptyState(this.controllers.size > 0, payload.message);
  }
}

class WhiteChannelController {
  constructor(manager, channelId) {
    this.manager = manager;
    this.channelId = channelId;
    this.state = manager.createStateFromEntry(null);
    this.lastSend = 0;
    this.pendingSend = null;
    this.isInitializing = false;

    const fragment = manager.template ? manager.template.content.cloneNode(true) : null;
    this.root = fragment ? fragment.querySelector('[data-channel-card]') || fragment.firstElementChild : null;
    if (!this.root) {
      console.warn('White channel template missing root element');
      return;
    }
    if (fragment && this.root !== fragment) {
      this.root = fragment.querySelector('[data-channel-card]') || fragment.firstElementChild;
    }
    if (!this.root) {
      console.warn('White channel template missing card element');
      return;
    }

    this.labelEl = this.root.querySelector('[data-role="channel-label"]');
    this.effectSelect = this.root.querySelector('[data-role="effect"]');
    this.paramsEl = this.root.querySelector('[data-role="params"]');
    this.brightnessInput = this.root.querySelector('[data-role="brightness"]');
    this.lockBtn = this.root.querySelector('[data-role="lock"]');
    this.onBtn = this.root.querySelector('[data-role="on"]');
    this.offBtn = this.root.querySelector('[data-role="off"]');

    if (this.labelEl) {
      this.labelEl.textContent = this.channelId;
    }

    this.populateEffectOptions(this.state.effect);
    this.bindListeners();
    this.applyState(null);
  }

  get channelValue() {
    return toChannelValue(this.channelId);
  }

  bindListeners() {
    if (this.effectSelect) {
      this.effectSelect.addEventListener('change', () => this.handleEffectChange());
    }
    if (this.brightnessInput) {
      this.brightnessInput.addEventListener('input', () => this.handleBrightnessInput());
    }
    if (this.lockBtn) {
      this.lockBtn.addEventListener('click', () => this.handleLockClick());
    }
    if (this.onBtn) {
      this.onBtn.addEventListener('click', () => this.handleOnClick());
    }
    if (this.offBtn) {
      this.offBtn.addEventListener('click', () => this.handleOffClick());
    }
  }

  populateEffectOptions(effect) {
    if (!this.effectSelect) return '';
    const options = this.manager.effectOptions;
    const existing = new Set();
    this.effectSelect.innerHTML = '';
    options.forEach((value) => {
      if (!value) return;
      const opt = document.createElement('option');
      opt.value = value;
      opt.textContent = value;
      this.effectSelect.appendChild(opt);
      existing.add(value);
    });
    if (effect && !existing.has(effect)) {
      const opt = document.createElement('option');
      opt.value = effect;
      opt.textContent = effect;
      opt.dataset.dynamic = 'true';
      this.effectSelect.appendChild(opt);
    }
    if (effect) {
      this.effectSelect.value = effect;
    } else if (this.effectSelect.options.length) {
      this.effectSelect.value = this.effectSelect.options[0].value;
    }
    return this.effectSelect.value;
  }

  renderParams(initialParams) {
    if (!this.paramsEl) return;
    const effect = this.effectSelect ? this.effectSelect.value.trim() : this.manager.getDefaultEffect();
    const defs = this.manager.getParamDefs(effect);
    renderParams(defs, this.paramsEl, () => this.scheduleSend(), initialParams);
  }

  applyState(entry) {
    const previous = this.state || this.manager.createStateFromEntry(null);
    const nextState = entry ? this.manager.createStateFromEntry(entry) : previous;
    nextState.paramCache = { ...(previous.paramCache || {}), ...(nextState.paramCache || {}) };
    if (!nextState.effect) {
      nextState.effect = previous.effect || this.manager.getDefaultEffect();
    }
    this.state = nextState;
    if (!this.root) return;
    const effect = nextState.effect || this.manager.getDefaultEffect();
    this.isInitializing = true;
    try {
      const selected = this.populateEffectOptions(effect);
      const params = nextState.paramCache ? nextState.paramCache[selected] : undefined;
      this.renderParams(Array.isArray(params) ? params : undefined);
      const brightness =
        typeof nextState.brightness === 'number' && !Number.isNaN(nextState.brightness)
          ? Math.max(0, Math.min(255, Math.round(nextState.brightness)))
          : 255;
      if (this.brightnessInput) {
        this.brightnessInput.value = String(brightness);
      }
      this.applyLimit(undefined, { silent: true });
    } finally {
      this.isInitializing = false;
    }
  }

  clampBrightness(value) {
    let num = typeof value === 'number' ? value : Number(value);
    if (Number.isNaN(num)) return null;
    const limit = this.manager.getLimit(this.channelId);
    if (typeof limit === 'number') {
      num = Math.min(num, limit);
    }
    if (num < 0) num = 0;
    if (num > 255) num = 255;
    return Math.round(num);
  }

  applyLimit(explicitLimit, options = {}) {
    const silent = Boolean(options.silent);
    const limit =
      explicitLimit !== undefined && explicitLimit !== null
        ? Number(explicitLimit)
        : this.manager.getLimit(this.channelId);
    const hasLimit = typeof limit === 'number' && !Number.isNaN(limit);
    const maxValue = hasLimit ? Math.max(0, Math.min(255, Math.round(limit))) : 255;
    if (this.brightnessInput) {
      this.brightnessInput.max = String(maxValue);
      const current = Number(this.brightnessInput.value);
      const adjusted = Number.isNaN(current) ? maxValue : Math.max(0, Math.min(current, maxValue));
      if (Number.isNaN(current) || adjusted !== current) {
        const prevInit = this.isInitializing;
        this.isInitializing = true;
        this.brightnessInput.value = String(adjusted);
        this.isInitializing = prevInit;
        if (!this.isInitializing && !silent) {
          this.state.brightness = adjusted;
          this.scheduleSend();
        }
      }
    }
    if (this.lockBtn) {
      this.lockBtn.textContent = hasLimit ? 'ðŸ”’' : 'ðŸ”“';
      this.lockBtn.setAttribute('aria-pressed', hasLimit ? 'true' : 'false');
      this.lockBtn.title = hasLimit
        ? `Unlock brightness limit (${maxValue})`
        : 'Lock brightness to current value';
    }
  }

  collectParams(effect) {
    const defs = this.manager.getParamDefs(effect);
    const params = collectParams(defs, this.paramsEl || document.createElement('div')) || [];
    return Array.isArray(params) ? params : [];
  }

  scheduleSend() {
    if (this.isInitializing) return;
    const now = Date.now();
    const delay = 100 - (now - this.lastSend);
    if (delay <= 0) {
      this.lastSend = now;
      this.sendWhite();
    } else {
      clearTimeout(this.pendingSend);
      this.pendingSend = setTimeout(() => {
        this.lastSend = Date.now();
        this.sendWhite();
      }, delay);
    }
  }

  sendWhite(options = {}) {
    if (this.isInitializing) return;
    const effect =
      options.effect !== undefined
        ? String(options.effect).trim()
        : this.effectSelect
        ? this.effectSelect.value.trim()
        : this.state.effect || this.manager.getDefaultEffect();
    if (!effect) return;
    let brightness;
    if (options.brightness !== undefined) {
      brightness = Number(options.brightness);
    } else if (this.brightnessInput) {
      brightness = Number(this.brightnessInput.value);
    } else {
      brightness = this.state.brightness;
    }
    if (Number.isNaN(brightness)) return;
    const clamped = this.clampBrightness(brightness);
    if (clamped === null) return;
    brightness = clamped;
    if (options.updateSlider !== false && this.brightnessInput) {
      this.brightnessInput.value = String(brightness);
    }
    let params;
    if (options.params !== undefined) {
      params = Array.isArray(options.params) ? options.params.slice() : [];
    } else {
      params = this.collectParams(effect);
    }
    const message = {
      channel: this.channelValue,
      effect,
      brightness,
    };
    if (Array.isArray(params) && params.length) {
      message.params = params;
    }
    this.manager
      .post(`/api/node/${encodeURIComponent(NODE_ID)}/white/set`, message)
      .catch(() => {
        alert('Request failed');
      });
    if (options.updateState !== false) {
      this.state.effect = effect;
      this.state.brightness = brightness;
      if (!this.state.paramCache) this.state.paramCache = {};
      this.state.paramCache[effect] = Array.isArray(params) ? params.slice() : [];
    }
  }

  async handleLockClick() {
    const currentLimit = this.manager.getLimit(this.channelId);
    if (typeof currentLimit === 'number') {
      await this.manager.persistLimit(this.channelId, null);
      this.applyLimit(null, { silent: false });
      return;
    }
    const clamped = this.clampBrightness(this.brightnessInput ? this.brightnessInput.value : this.state.brightness);
    if (clamped === null) {
      alert('Invalid brightness');
      return;
    }
    const limit = await this.manager.persistLimit(this.channelId, clamped);
    this.applyLimit(limit, { silent: false });
  }

  handleEffectChange() {
    const effect = this.effectSelect ? this.effectSelect.value.trim() : '';
    const target = effect || this.manager.getDefaultEffect();
    if (!this.state.paramCache) this.state.paramCache = {};
    const cached = this.state.paramCache[target];
    const prevInit = this.isInitializing;
    this.isInitializing = true;
    try {
      this.populateEffectOptions(target);
      this.renderParams(Array.isArray(cached) ? cached : undefined);
    } finally {
      this.isInitializing = prevInit;
    }
    this.state.effect = target;
    this.scheduleSend();
  }

  handleBrightnessInput() {
    if (!this.brightnessInput) return;
    const clamped = this.clampBrightness(this.brightnessInput.value);
    if (clamped === null) return;
    if (clamped !== Number(this.brightnessInput.value)) {
      const prevInit = this.isInitializing;
      this.isInitializing = true;
      this.brightnessInput.value = String(clamped);
      this.isInitializing = prevInit;
    }
    this.state.brightness = clamped;
    this.scheduleSend();
  }

  handleOnClick() {
    const limit = this.manager.getLimit(this.channelId);
    const target = typeof limit === 'number' ? limit : 255;
    if (this.brightnessInput) {
      this.brightnessInput.value = String(target);
    }
    this.state.brightness = target;
    this.sendWhite({ brightness: target });
  }

  handleOffClick() {
    if (this.brightnessInput) {
      this.brightnessInput.value = '0';
    }
    this.sendWhite({ effect: 'solid', brightness: 0, params: [], updateState: true });
  }

  destroy() {
    clearTimeout(this.pendingSend);
    if (this.root && this.root.parentElement) {
      this.root.parentElement.removeChild(this.root);
    }
  }
}

function resolveHost(host) {
  if (host && host.nodeType === 1) {
    return host;
  }
  return document.querySelector('[data-module="white"]');
}

window.nodeModuleLoaders = window.nodeModuleLoaders || {};
window.nodeModuleLoaders.white = function initWhiteModule(payload = {}, host) {
  const wrapper = resolveHost(host);
  if (!wrapper) return;
  let manager = wrapper[MANAGER_REF];
  if (!manager) {
    manager = new WhiteModuleManager(wrapper);
    wrapper[MANAGER_REF] = manager;
  }
  manager.update(payload);
};
</script>
