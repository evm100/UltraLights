<section class="glass rounded-2xl p-6" data-module-root>
  <header class="mb-4">
    <h3 class="text-lg font-semibold">RGB Strips</h3>
    <p class="mt-2 text-sm text-slate-400 hidden" data-module-empty-message>
      No RGB strips reported.
    </p>
  </header>
  <div class="flex flex-col gap-4" data-channel-list></div>
  <template data-channel-template>
    <article
      class="rounded-xl border border-slate-800/60 bg-slate-900/40 p-4 space-y-4"
      data-channel-card
    >
      <header class="flex items-center justify-between">
        <h4 class="text-base font-semibold">
          <input
            type="text"
            data-role="channel-name"
            class="bg-transparent text-base font-semibold border border-transparent rounded px-2 py-1 focus:outline-none focus:border-slate-600 focus:bg-slate-900/60"
            maxlength="80"
            autocomplete="off"
            spellcheck="false"
          />
        </h4>
        <span class="text-xs uppercase tracking-wide opacity-70" data-role="effect-label"></span>
      </header>
      <div class="space-y-2" data-role="params"></div>
      <div class="space-y-2">
        <div class="flex items-center justify-between">
          <label class="text-xs opacity-70">Brightness</label>
          <button
            type="button"
            class="text-xl leading-none"
            data-role="lock"
            title="Lock brightness"
            aria-pressed="false"
          >
            ðŸ”“
          </button>
        </div>
        <input
          type="range"
          min="0"
          max="255"
          value="255"
          data-role="brightness"
          class="w-full"
        />
      </div>
      <div class="flex gap-2">
        <button
          type="button"
          class="px-4 py-2 pill bg-green-600 hover:bg-green-500 text-white"
          data-role="on"
        >
          On
        </button>
        <button
          type="button"
          class="px-4 py-2 pill bg-red-600 hover:bg-red-500 text-white"
          data-role="off"
        >
          Off
        </button>
      </div>
    </article>
  </template>
</section>
<script src="https://cdn.jsdelivr.net/npm/@jaames/iro@5"></script>
<script type="module">
import { renderParams, collectParams } from '/static/params.js';

const RGB_PARAM_DEFS = {{ rgb_param_defs|tojson }};
const MODULE_KEY = 'rgb';
const NODE_ID = {{ node.id|tojson }};
const MANAGER_REF = Symbol('rgb-module-manager');

const EFFECT_KEYS = Object.keys(RGB_PARAM_DEFS || {});
const DEFAULT_EFFECT =
  (RGB_PARAM_DEFS && RGB_PARAM_DEFS.solid ? 'solid' : null) || EFFECT_KEYS[0] || 'solid';
const FALLBACK_PARAMS =
  (RGB_PARAM_DEFS && RGB_PARAM_DEFS[DEFAULT_EFFECT]) || [{ type: 'color', label: 'Color' }];

function toChannelValue(channel) {
  const num = Number(channel);
  return Number.isNaN(num) ? String(channel) : num;
}

function normalizeChannelId(value) {
  if (value === null || value === undefined) return null;
  const str = String(value).trim();
  return str === '' ? null : str;
}

class RgbModuleManager {
  constructor(host) {
    this.host = host;
    this.listEl = host.querySelector('[data-channel-list]');
    this.template = host.querySelector('template[data-channel-template]');
    this.emptyMessage = host.querySelector('[data-module-empty-message]');
    this.defaultEmptyMessage = this.emptyMessage ? this.emptyMessage.textContent : '';
    this.controllers = new Map();
    this.nameCache = new Map();
    this.labelPrefix = 'Strip';
    this.ready = Boolean(this.listEl && this.template);
    if (!this.ready) {
      console.warn('RGB module template missing host container');
    }
  }

  getParamDefs(effect) {
    if (RGB_PARAM_DEFS && RGB_PARAM_DEFS[effect]) {
      return RGB_PARAM_DEFS[effect];
    }
    return FALLBACK_PARAMS;
  }

  getDefaultEffect() {
    return DEFAULT_EFFECT;
  }

  getDefaultName(channelId) {
    return `${this.labelPrefix} ${channelId}`;
  }

  cacheName(channelId, name) {
    const key = String(channelId);
    const clean = typeof name === 'string' ? name.trim() : '';
    if (clean) {
      this.nameCache.set(key, clean);
    } else {
      this.nameCache.delete(key);
    }
  }

  getCachedName(channelId) {
    const key = String(channelId);
    const value = this.nameCache.get(key);
    return typeof value === 'string' ? value : '';
  }

  post(path, body) {
    return fetch(path, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    }).then((res) => {
      if (!res.ok) {
        throw new Error(`Request failed with status ${res.status}`);
      }
      return res;
    });
  }

  async persistName(channelId, name) {
    const trimmed = typeof name === 'string' ? name.trim() : '';
    const payload = {
      channel: toChannelValue(channelId),
      name: trimmed ? trimmed : null,
    };
    try {
      const res = await this.post(
        `/api/node/${encodeURIComponent(NODE_ID)}/${MODULE_KEY}/channel-name`,
        payload,
      );
      let response = null;
      try {
        response = await res.json();
      } catch (err) {
        response = null;
      }
      let stored = '';
      if (response && Object.prototype.hasOwnProperty.call(response, 'name')) {
        const value = response.name;
        if (typeof value === 'string' && value.trim()) {
          stored = value.trim();
        }
      } else {
        stored = trimmed;
      }
      this.cacheName(channelId, stored);
      return stored;
    } catch (err) {
      console.error(err);
      alert('Request failed');
      throw err;
    }
  }

  getLimit(channel) {
    const data = window.nodeBrightnessLimits;
    if (!data) return null;
    const moduleData = data[MODULE_KEY];
    if (!moduleData) return null;
    const value = moduleData[String(channel)];
    return typeof value === 'number' && !Number.isNaN(value) ? value : null;
  }

  cacheLimit(channel, limit) {
    const data = window.nodeBrightnessLimits || (window.nodeBrightnessLimits = {});
    const key = String(channel);
    if (limit === null || limit === undefined) {
      const moduleData = data[MODULE_KEY];
      if (moduleData) {
        delete moduleData[key];
        if (Object.keys(moduleData).length === 0) {
          delete data[MODULE_KEY];
        }
      }
      return;
    }
    const moduleData = data[MODULE_KEY] || (data[MODULE_KEY] = {});
    moduleData[key] = limit;
  }

  async persistLimit(channel, limit) {
    const payload = { channel: toChannelValue(channel), limit };
    try {
      const res = await this.post(`/api/node/${encodeURIComponent(NODE_ID)}/rgb/brightness-limit`, payload);
      let response = null;
      try {
        response = await res.json();
      } catch (err) {
        response = null;
      }
      if (response && response.limit !== undefined) {
        const value = response.limit;
        if (typeof value === 'number' && !Number.isNaN(value)) {
          const clamped = Math.max(0, Math.min(255, Math.round(value)));
          this.cacheLimit(channel, clamped);
          return clamped;
        }
        this.cacheLimit(channel, null);
        return null;
      }
      if (typeof limit === 'number' && !Number.isNaN(limit)) {
        const clamped = Math.max(0, Math.min(255, Math.round(limit)));
        this.cacheLimit(channel, clamped);
        return clamped;
      }
      this.cacheLimit(channel, null);
      return null;
    } catch (err) {
      console.error(err);
      alert('Request failed');
      return this.getLimit(channel);
    }
  }

  createStateFromEntry(entry) {
    const state = {
      effect: this.getDefaultEffect(),
      brightness: 255,
      paramCache: {},
      name: '',
    };
    if (entry && typeof entry === 'object') {
      if (typeof entry.effect === 'string' && entry.effect.trim()) {
        state.effect = entry.effect.trim();
      }
      if (typeof entry.brightness === 'number' && !Number.isNaN(entry.brightness)) {
        state.brightness = Math.max(0, Math.min(255, Math.round(entry.brightness)));
      }
      const params =
        (Array.isArray(entry.params) && entry.params.length ? entry.params : null) ||
        (Array.isArray(entry.color) && entry.color.length ? entry.color.slice(0, 3) : null);
      if (params) {
        const normalized = this.normalizeParams(params);
        if (normalized && normalized.length) {
          state.paramCache[state.effect] = normalized;
        }
      }
      if (typeof entry.name === 'string' && entry.name.trim()) {
        state.name = entry.name.trim();
      }
    }
    if (!state.effect) {
      state.effect = this.getDefaultEffect();
    }
    if (!state.paramCache) {
      state.paramCache = {};
    }
    return state;
  }

  normalizeParams(values) {
    if (!Array.isArray(values)) return undefined;
    const out = [];
    values.forEach((value) => {
      if (typeof value === 'number') {
        out.push(value);
      } else if (typeof value === 'string') {
        const num = Number(value);
        out.push(Number.isNaN(num) ? value : num);
      } else {
        const num = Number(value);
        if (!Number.isNaN(num)) {
          out.push(num);
        }
      }
    });
    return out;
  }

  clearControllers() {
    this.controllers.forEach((controller) => controller.destroy());
    this.controllers.clear();
    if (this.listEl) {
      this.listEl.innerHTML = '';
    }
  }

  updateEmptyState(hasChannels, message) {
    if (!this.emptyMessage) return;
    const text = typeof message === 'string' && message.trim() ? message : this.defaultEmptyMessage;
    this.emptyMessage.textContent = text;
    this.emptyMessage.classList.toggle('hidden', hasChannels);
  }

  ensureController(channel) {
    const key = String(channel);
    let controller = this.controllers.get(key);
    if (!controller) {
      controller = new RgbChannelController(this, key);
      if (controller.root) {
        this.controllers.set(key, controller);
      }
    }
    return controller;
  }

  update(payload = {}) {
    if (!this.ready) return;
    if (payload.available === false) {
      this.clearControllers();
      this.updateEmptyState(false, payload.message);
      return;
    }
    const stateEntries = payload.state && typeof payload.state === 'object' ? payload.state : {};
    const providedChannels = Array.isArray(payload.channels) ? payload.channels : null;
    const channelIds = providedChannels && providedChannels.length
      ? providedChannels
      : Object.keys(stateEntries || {});
    const normalized = channelIds
      .map(normalizeChannelId)
      .filter((value) => value !== null);
    const sorted = normalized.sort((a, b) => {
      const numA = Number(a);
      const numB = Number(b);
      const aIsNum = !Number.isNaN(numA);
      const bIsNum = !Number.isNaN(numB);
      if (aIsNum && bIsNum) return numA - numB;
      if (aIsNum) return -1;
      if (bIsNum) return 1;
      return a.localeCompare(b);
    });
    const seen = new Set();
    sorted.forEach((channelId) => {
      const controller = this.ensureController(channelId);
      if (!controller) return;
      seen.add(channelId);
      const entry =
        stateEntries[channelId] !== undefined
          ? stateEntries[channelId]
          : stateEntries[String(Number(channelId))];
      controller.applyState(entry);
      const limits = payload.limits && typeof payload.limits === 'object' ? payload.limits : {};
      const limitValue = limits && limits[channelId] !== undefined ? limits[channelId] : limits[String(Number(channelId))];
      controller.applyLimit(limitValue, { silent: true });
      if (this.listEl) {
        this.listEl.appendChild(controller.root);
      }
    });
    Array.from(this.controllers.keys()).forEach((key) => {
      if (!seen.has(key)) {
        const controller = this.controllers.get(key);
        if (controller) {
          controller.destroy();
        }
        this.controllers.delete(key);
      }
    });
    this.updateEmptyState(this.controllers.size > 0, payload.message);
  }
}

class RgbChannelController {
  constructor(manager, channelId) {
    this.manager = manager;
    this.channelId = channelId;
    this.state = manager.createStateFromEntry(null);
    this.lastSend = 0;
    this.pendingSend = null;
    this.isInitializing = false;

    const fragment = manager.template ? manager.template.content.cloneNode(true) : null;
    this.root = fragment ? fragment.querySelector('[data-channel-card]') || fragment.firstElementChild : null;
    if (!this.root) {
      console.warn('RGB channel template missing root element');
      return;
    }

    this.nameInput = this.root.querySelector('[data-role="channel-name"]');
    this.defaultName = this.manager.getDefaultName(this.channelId);
    if (this.nameInput) {
      this.nameInput.value = this.defaultName;
      this.nameInput.placeholder = this.defaultName;
    }
    this.effectLabelEl = this.root.querySelector('[data-role="effect-label"]');
    this.paramsEl = this.root.querySelector('[data-role="params"]');
    this.brightnessInput = this.root.querySelector('[data-role="brightness"]');
    this.lockBtn = this.root.querySelector('[data-role="lock"]');
    this.onBtn = this.root.querySelector('[data-role="on"]');
    this.offBtn = this.root.querySelector('[data-role="off"]');

    this.bindListeners();
    this.applyState(null);
  }

  get channelValue() {
    return toChannelValue(this.channelId);
  }

  bindListeners() {
    if (this.nameInput) {
      this.nameInput.addEventListener('blur', () => this.commitName());
      this.nameInput.addEventListener('keydown', (event) => this.handleNameKeyDown(event));
    }
    if (this.brightnessInput) {
      this.brightnessInput.addEventListener('input', () => this.handleBrightnessInput());
    }
    if (this.lockBtn) {
      this.lockBtn.addEventListener('click', () => this.handleLockClick());
    }
    if (this.onBtn) {
      this.onBtn.addEventListener('click', () => this.handleOnClick());
    }
    if (this.offBtn) {
      this.offBtn.addEventListener('click', () => this.handleOffClick());
    }
  }

  setName(name, options = {}) {
    const clean = typeof name === 'string' ? name.trim() : '';
    this.state.name = clean;
    if (options.cache) {
      this.manager.cacheName(this.channelId, clean);
    }
    if (this.nameInput) {
      const display = clean || this.defaultName;
      if (this.nameInput.value !== display) {
        this.nameInput.value = display;
      }
      if (!this.nameInput.placeholder) {
        this.nameInput.placeholder = this.defaultName;
      }
    }
  }

  handleNameKeyDown(event) {
    if (event.key === 'Enter') {
      event.preventDefault();
      if (this.nameInput) {
        this.nameInput.blur();
      }
    } else if (event.key === 'Escape') {
      event.preventDefault();
      this.setName(this.state.name, { cache: false });
      if (this.nameInput) {
        this.nameInput.blur();
      }
    }
  }

  commitName() {
    if (!this.nameInput || this.nameInput.disabled) {
      return;
    }
    const raw = this.nameInput.value;
    const trimmed = typeof raw === 'string' ? raw.trim() : '';
    const desired = trimmed && trimmed !== this.defaultName ? trimmed : '';
    const previous = typeof this.state.name === 'string' ? this.state.name : '';
    if (desired === previous) {
      this.setName(previous, { cache: false });
      return;
    }
    this.nameInput.disabled = true;
    this.manager
      .persistName(this.channelId, desired)
      .then((stored) => {
        this.setName(stored, { cache: true });
      })
      .catch(() => {
        this.setName(previous, { cache: true });
      })
      .finally(() => {
        if (this.nameInput) {
          this.nameInput.disabled = false;
        }
      });
  }

  renderParams(initialParams) {
    if (!this.paramsEl) return;
    const effect = this.state.effect || this.manager.getDefaultEffect();
    const defs = this.manager.getParamDefs(effect);
    renderParams(defs, this.paramsEl, () => this.scheduleSend(), initialParams);
  }

  applyState(entry) {
    const previous = this.state || this.manager.createStateFromEntry(null);
    const nextState = entry ? this.manager.createStateFromEntry(entry) : previous;
    nextState.paramCache = { ...(previous.paramCache || {}), ...(nextState.paramCache || {}) };
    if (!nextState.effect) {
      nextState.effect = previous.effect || this.manager.getDefaultEffect();
    }
    const entryHasName =
      entry && typeof entry === 'object' && Object.prototype.hasOwnProperty.call(entry, 'name');
    const previousName = typeof previous.name === 'string' ? previous.name : '';
    let resolvedName = '';
    if (entryHasName) {
      resolvedName = typeof nextState.name === 'string' ? nextState.name : '';
    } else if (previousName) {
      resolvedName = previousName;
    } else {
      const cached = this.manager.getCachedName(this.channelId);
      if (cached) {
        resolvedName = cached;
      }
    }
    nextState.name = resolvedName;
    this.state = nextState;
    this.setName(resolvedName, { cache: entryHasName });
    this.isInitializing = true;
    try {
      const effect = nextState.effect || this.manager.getDefaultEffect();
      if (this.effectLabelEl) {
        this.effectLabelEl.textContent = effect;
      }
      const params = nextState.paramCache ? nextState.paramCache[effect] : undefined;
      this.renderParams(Array.isArray(params) ? params : undefined);
      const brightness =
        typeof nextState.brightness === 'number' && !Number.isNaN(nextState.brightness)
          ? Math.max(0, Math.min(255, Math.round(nextState.brightness)))
          : 255;
      if (this.brightnessInput) {
        this.brightnessInput.value = String(brightness);
      }
      this.applyLimit(undefined, { silent: true });
    } finally {
      this.isInitializing = false;
    }
  }

  clampBrightness(value) {
    let num = typeof value === 'number' ? value : Number(value);
    if (Number.isNaN(num)) return null;
    const limit = this.manager.getLimit(this.channelId);
    if (typeof limit === 'number') {
      num = Math.min(num, limit);
    }
    if (num < 0) num = 0;
    if (num > 255) num = 255;
    return Math.round(num);
  }

  applyLimit(explicitLimit, options = {}) {
    const silent = Boolean(options.silent);
    const limit =
      explicitLimit !== undefined && explicitLimit !== null
        ? Number(explicitLimit)
        : this.manager.getLimit(this.channelId);
    const hasLimit = typeof limit === 'number' && !Number.isNaN(limit);
    const maxValue = hasLimit ? Math.max(0, Math.min(255, Math.round(limit))) : 255;
    if (this.brightnessInput) {
      this.brightnessInput.max = String(maxValue);
      const current = Number(this.brightnessInput.value);
      const adjusted = Number.isNaN(current) ? maxValue : Math.max(0, Math.min(current, maxValue));
      if (Number.isNaN(current) || adjusted !== current) {
        const prevInit = this.isInitializing;
        this.isInitializing = true;
        this.brightnessInput.value = String(adjusted);
        this.isInitializing = prevInit;
        if (!this.isInitializing && !silent) {
          this.state.brightness = adjusted;
          this.scheduleSend();
        }
      }
    }
    if (this.lockBtn) {
      this.lockBtn.textContent = hasLimit ? 'ðŸ”’' : 'ðŸ”“';
      this.lockBtn.setAttribute('aria-pressed', hasLimit ? 'true' : 'false');
      this.lockBtn.title = hasLimit
        ? `Unlock brightness limit (${maxValue})`
        : 'Lock brightness to current value';
    }
  }

  collectParams() {
    const effect = this.state.effect || this.manager.getDefaultEffect();
    const defs = this.manager.getParamDefs(effect);
    const params = collectParams(defs, this.paramsEl || document.createElement('div')) || [];
    const out = Array.isArray(params) ? params.slice() : [];
    while (out.length < 3) out.push(0);
    return out;
  }

  scheduleSend() {
    if (this.isInitializing) return;
    const now = Date.now();
    const delay = 100 - (now - this.lastSend);
    if (delay <= 0) {
      this.lastSend = now;
      this.sendRgb();
    } else {
      clearTimeout(this.pendingSend);
      this.pendingSend = setTimeout(() => {
        this.lastSend = Date.now();
        this.sendRgb();
      }, delay);
    }
  }

  sendRgb(options = {}) {
    if (this.isInitializing) return;
    const effect = this.state.effect || this.manager.getDefaultEffect();
    let brightness;
    if (options.brightness !== undefined) {
      brightness = Number(options.brightness);
    } else if (this.brightnessInput) {
      brightness = Number(this.brightnessInput.value);
    } else {
      brightness = this.state.brightness;
    }
    if (Number.isNaN(brightness)) return;
    const clamped = this.clampBrightness(brightness);
    if (clamped === null) return;
    brightness = clamped;
    if (options.updateSlider !== false && this.brightnessInput) {
      this.brightnessInput.value = String(brightness);
    }
    let params;
    if (options.params !== undefined) {
      params = Array.isArray(options.params) ? options.params.slice() : [];
    } else {
      params = this.collectParams();
    }
    if (!Array.isArray(params)) {
      params = [];
    }
    const message = { strip: this.channelValue, effect, brightness, params };
    this.manager
      .post(`/api/node/${encodeURIComponent(NODE_ID)}/rgb/set`, message)
      .catch(() => {
        alert('Request failed');
      });
    if (options.updateState !== false) {
      this.state.brightness = brightness;
      if (!this.state.paramCache) this.state.paramCache = {};
      this.state.paramCache[effect] = params.slice();
    }
  }

  async handleLockClick() {
    const currentLimit = this.manager.getLimit(this.channelId);
    if (typeof currentLimit === 'number') {
      await this.manager.persistLimit(this.channelId, null);
      this.applyLimit(null, { silent: false });
      return;
    }
    const clamped = this.clampBrightness(this.brightnessInput ? this.brightnessInput.value : this.state.brightness);
    if (clamped === null) {
      alert('Invalid brightness');
      return;
    }
    const limit = await this.manager.persistLimit(this.channelId, clamped);
    this.applyLimit(limit, { silent: false });
  }

  handleBrightnessInput() {
    if (!this.brightnessInput) return;
    const clamped = this.clampBrightness(this.brightnessInput.value);
    if (clamped === null) return;
    if (clamped !== Number(this.brightnessInput.value)) {
      const prevInit = this.isInitializing;
      this.isInitializing = true;
      this.brightnessInput.value = String(clamped);
      this.isInitializing = prevInit;
    }
    this.state.brightness = clamped;
    this.scheduleSend();
  }

  handleOnClick() {
    const limit = this.manager.getLimit(this.channelId);
    const target = typeof limit === 'number' ? limit : 255;
    if (this.brightnessInput) {
      this.brightnessInput.value = String(target);
    }
    this.state.brightness = target;
    this.sendRgb({ brightness: target });
  }

  handleOffClick() {
    if (this.brightnessInput) {
      this.brightnessInput.value = '0';
    }
    this.sendRgb({ brightness: 0, params: [0, 0, 0] });
  }

  destroy() {
    clearTimeout(this.pendingSend);
    if (this.root && this.root.parentElement) {
      this.root.parentElement.removeChild(this.root);
    }
  }
}

function resolveHost(host) {
  if (host && host.nodeType === 1) {
    return host;
  }
  return document.querySelector('[data-module="rgb"]');
}

window.nodeModuleLoaders = window.nodeModuleLoaders || {};
window.nodeModuleLoaders.rgb = function initRgbModule(payload = {}, host) {
  const wrapper = resolveHost(host);
  if (!wrapper) return;
  let manager = wrapper[MANAGER_REF];
  if (!manager) {
    manager = new RgbModuleManager(wrapper);
    wrapper[MANAGER_REF] = manager;
  }
  manager.update(payload);
};
</script>
